---
layout: post
title: Swift学习笔记
category: IOS
tags: [IOS,Swift]
---

### 基础部分

#### 常量和变量

用let来声明常量，用var来声明变量

#### 类型推断

初始化常量或者变量的时候如果所赋的值类型已知，就可以触发类型推断。

#### 类型标注

如果声明时不初始化，使用类型标注：需要在常量或者变量名后面加上一个冒号和空格，然后加上类型名称。

    var welcomeMessage: String

#### 字符串插值

字符串插值：将常量或变量名放入圆括号中，并在开括号前使用反斜杠将其转义。

    println("The current value of friendlyWelcome is \(friendlyWelcome)")
    // 输出 "The current value of friendlyWelcome is Bonjour!

#### 嵌套注释

通过运用嵌套多行注释，你可以快速方便的注释掉一大段代码，即使这段代码之中已经含有了多行注释块。

    /* 这是第一个多行注释的开头
    /* 这是第二个被嵌套的多行注释 */
    这是第一个多行注释的结尾 */

#### 类型安全

swift是类型安全的，会在编译你的代码时进行类型检查。

#### 元祖

高阶数据类型比如元组，可以让你创建或者传递一组数据，比如作为函数的返回值时，你可以用一个元组可以返回多个值。

元组在函数返回值时很有用，但是并不适合创建复杂的数据结构。如果你的数据结构并不是临时使用，请使用类或者结构体而不是元组。

#### 可选类型

可选类型，用于处理值缺失的情况。可选表示“那儿有一个值，并且它等于 x ”或者“那儿没有值”。

可选值的强制解析：当你确定可选类型确实包含值之后，你可以在可选的名字后面加一个感叹号（!）来获取值。

#### 类型别名

类型别名就是给现有类型定义另一个名字。你可以使用`typealias`关键字来定义类型别名。

#### 可选绑定

    if let actualNumber = possibleNumber.toInt() {
        println("\(possibleNumber) has an integer value of \(actualNumber)")
    } else {
        println("\(possibleNumber) could not be converted to an integer")
    }
    // 输出 "123 has an integer value of 123"

> “如果possibleNumber.toInt返回的可选Int包含一个值，创建一个叫做actualNumber的新常量并将可选包含的值赋给它。”
如果转换成功，actualNumber常量可以在if语句的第一个分支中使用。它已经被可选类型包含的值初始化过，所以不需要再使用 `!`后缀来获取它的值。在这个例子中，actualNumber只被用来输出转换结果。
你可以在可选绑定中使用常量和变量。如果你想在if语句的第一个分支中操作actualNumber的值，你可以改成if var actualNumber，这样可选类型包含的值就会被赋给一个变量而非常量。

#### nil

    var serverResponseCode: Int? = 404
    // serverResponseCode 包含一个可选的 Int 值 404
    serverResponseCode = nil
    // serverResponseCode 现在不包含值

nil不能用于非可选的常量和变量。如果你的代码中有常量或者变量需要处理值缺失的情况，请把它们声明成对应的可选类型。

#### 断言

向assert函数传入一个结果为true或者false的表达式以及一条信息，当表达式为false的时候这条信息会被显示：

    let age = -3
    assert(age >= 0, "A person's age cannot be less than zero")
    // 因为 age < 0，所以断言会触发

在这个例子中，只有age >= 0为true的时候，即age的值非负的时候，代码运行才会继续。如果age的值是负数，就像代码中那样，age >= 0为false，断言被触发，结束应用。

断言的适用情景：

1. 整数类型的下标索引被传入一个自定义下标脚本实现，但是下标索引值可能太小或者太大。

2. 需要给函数传入一个值，但是非法的值可能导致函数不能正常执行。

3. 一个可选值现在是nil，但是后面的代码运行需要一个非nil值。

### 基本运算符

#### 赋值

赋值操作并不返回任何值，这个特性使你无法把（==）错写成（=）

#### 算术运算

默认情况下不允许在数值运算中出现溢出情况。但是你可以使用 Swift 的溢出运算符来实现溢出运算（如`a &+ b`）

#### 空合运算符

`a ?? b`将对可选类型a进行空判断，如果a包含一个值就进行解封，否则就返回一个默认值b

相当于`a != nil ? a! : b` 

#### 区间运算符

`a...b`：从a到b(包括a和b)

`a..<b`：从a到b但不包括b

### 字符串和字符

Swift的`String`类型与`NSString`类进行了无缝桥接。

在 Objective-C 和 Cocoa 中，您通过选择两个不同的类(NSString和NSMutableString)来指定该字符串是否可以被修改，Swift 中的字符串是否可以修改仅通过定义的是变量还是常量来决定，实现了多种类型可变性操作的统一。

#### 值类型

如果您创建了一个新的字符串，那么当其进行常量、变量赋值操作或在函数/方法中传递时，会进行值拷贝。 任何情况下，都会对已有字符串值创建新副本，并对该新副本进行传递或赋值操作。 

Swift 默认字符串拷贝的方式保证了在函数/方法中传递的是字符串的值。 很明显无论该值来自于哪里，都是您独自拥有的。 您可以放心您传递的字符串本身不会被更改。

> swift这个特性和java是一样的。

与 Cocoa 中的NSString不同，当您在 Cocoa 中创建了一个NSString实例，并将其传递给一个函数/方法，或者赋值给一个变量，您传递或赋值的是该NSString实例的一个引用，除非您特别要求进行值拷贝，否则字符串不会生成新的副本来进行赋值操作。

#### 字符串比较

用`==`可以来比较两string内容是否一样。

