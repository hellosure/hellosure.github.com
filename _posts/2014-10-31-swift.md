---
layout: post
title: Swift学习笔记
category: IOS
tags: [IOS,Swift]
---

### 基础部分

#### 常量和变量

用`let`来声明常量，用`var`来声明变量

#### 类型推断

初始化常量或者变量的时候如果所赋的值类型已知，就可以触发类型推断。

#### 类型标注

如果声明时不初始化，使用类型标注：需要在常量或者变量名后面加上一个冒号和空格，然后加上类型名称。

    var welcomeMessage: String

#### 字符串插值

字符串插值：将常量或变量名放入圆括号中，并在开括号前使用反斜杠将其转义。

    println("The current value of friendlyWelcome is \(friendlyWelcome)")
    // 输出 "The current value of friendlyWelcome is Bonjour!

#### 嵌套注释

通过运用嵌套多行注释，你可以快速方便的注释掉一大段代码，即使这段代码之中已经含有了多行注释块。

    /* 这是第一个多行注释的开头
    /* 这是第二个被嵌套的多行注释 */
    这是第一个多行注释的结尾 */

#### 类型安全

swift是类型安全的，会在编译你的代码时进行类型检查。

#### 元祖

高阶数据类型比如元组，可以让你创建或者传递一组数据，比如作为函数的返回值时，你可以用一个元组可以返回多个值。

元组在函数返回值时很有用，但是并不适合创建复杂的数据结构。如果你的数据结构并不是临时使用，请使用类或者结构体而不是元组。

#### 可选类型

可选类型，用于处理值缺失的情况。可选表示“那儿有一个值，并且它等于 x ”或者“那儿没有值”。

可选值的强制解析：当你确定可选类型确实包含值之后，你可以在可选的名字后面加一个感叹号`!`来获取值。

#### 类型别名

类型别名就是给现有类型定义另一个名字。你可以使用`typealias`关键字来定义类型别名。

#### 可选绑定

    if let actualNumber = possibleNumber.toInt() {
        println("\(possibleNumber) has an integer value of \(actualNumber)")
    } else {
        println("\(possibleNumber) could not be converted to an integer")
    }
    // 输出 "123 has an integer value of 123"

> “如果possibleNumber.toInt返回的可选Int包含一个值，创建一个叫做actualNumber的新常量并将可选包含的值赋给它。”
如果转换成功，actualNumber常量可以在if语句的第一个分支中使用。它已经被可选类型包含的值初始化过，所以不需要再使用 `!`后缀来获取它的值。在这个例子中，actualNumber只被用来输出转换结果。
你可以在可选绑定中使用常量和变量。如果你想在if语句的第一个分支中操作actualNumber的值，你可以改成if var actualNumber，这样可选类型包含的值就会被赋给一个变量而非常量。

#### nil

    var serverResponseCode: Int? = 404
    // serverResponseCode 包含一个可选的 Int 值 404
    serverResponseCode = nil
    // serverResponseCode 现在不包含值

`nil`不能用于非可选的常量和变量。如果你的代码中有常量或者变量需要处理值缺失的情况，请把它们声明成对应的可选类型。

#### 断言

向`assert`函数传入一个结果为true或者false的表达式以及一条信息，当表达式为false的时候这条信息会被显示：

    let age = -3
    assert(age >= 0, "A person's age cannot be less than zero")
    // 因为 age < 0，所以断言会触发

在这个例子中，只有age >= 0为true的时候，即age的值非负的时候，代码运行才会继续。如果age的值是负数，就像代码中那样，age >= 0为false，断言被触发，结束应用。

断言的适用情景：

1. 整数类型的下标索引被传入一个自定义下标脚本实现，但是下标索引值可能太小或者太大。

2. 需要给函数传入一个值，但是非法的值可能导致函数不能正常执行。

3. 一个可选值现在是nil，但是后面的代码运行需要一个非nil值。

### 基本运算符

#### 赋值

赋值操作并不返回任何值，这个特性使你无法把`==`错写成`=`

#### 算术运算

默认情况下不允许在数值运算中出现溢出情况。但是你可以使用 Swift 的溢出运算符来实现溢出运算（如`a &+ b`）

#### 空合运算符

`a ?? b`将对可选类型a进行空判断，如果a包含一个值就进行解封，否则就返回一个默认值b

相当于`a != nil ? a! : b` 

#### 区间运算符

`a...b`：从a到b(包括a和b)

`a..<b`：从a到b但不包括b

### 字符串和字符

Swift的`String`类型与`NSString`类进行了无缝桥接。

在 Objective-C 和 Cocoa 中，您通过选择两个不同的类(`NSString`和`NSMutableString`)来指定该字符串是否可以被修改，Swift 中的字符串是否可以修改仅通过定义的是变量还是常量来决定，实现了多种类型可变性操作的统一。

#### 值类型

如果您创建了一个新的字符串，那么当其进行常量、变量赋值操作或在函数/方法中传递时，会进行值拷贝。 任何情况下，都会对已有字符串值创建新副本，并对该新副本进行传递或赋值操作。 

Swift 默认字符串拷贝的方式保证了在函数/方法中传递的是字符串的值。 很明显无论该值来自于哪里，都是您独自拥有的。 您可以放心您传递的字符串本身不会被更改。

> swift这个特性和java是一样的。

与 Cocoa 中的NSString不同，当您在 Cocoa 中创建了一个NSString实例，并将其传递给一个函数/方法，或者赋值给一个变量，您传递或赋值的是该NSString实例的一个引用，除非您特别要求进行值拷贝，否则字符串不会生成新的副本来进行赋值操作。

#### 字符串比较

用`==`可以来比较两string内容是否一样。

### 集合类型

#### 数组

Swift 数组特定于它所存储元素的类型。这与 Objective-C 的 `NSArray` 和 `NSMutableArray` 不同，这两个类可以存储任意类型的对象，并且不提供所返回对象的任何特别信息。在 Swift 中，数据值在被存储进入某个数组之前类型必须明确，方法是通过显式的类型标注或类型推断，而且不是必须是class类型。例如： 如果我们创建了一个Int值类型的数组，我们不能往其中插入任何不是Int类型的数据。 Swift 中的数组是类型安全的，并且它们中包含的类型必须明确。

var shoppingList: [String] = ["Eggs", "Milk"]
var shoppingList = ["Eggs", "Milk"] //类型推断
// shoppingList 已经被构造并且拥有两个初始项。

Shoppinglist数组被声明为变量（var关键字创建）而不是常量（let创建）是因为以后可能会有更多的数据项被插入其中。

可以通过`+=`在数组尾部添加数据项。

使用`for-in`循环来遍历所有数组中的数据项：

{% highlight swift %}

for item in shoppingList {
    println(item)
}

{% endhighlight %}

enumerate返回一个由每一个数据项索引值和数据值组成的元组：

{% highlight swift %}

for (index, value) in enumerate(shoppingList) {
    println("Item \(index + 1): \(value)")
}

{% endhighlight %}

#### 字典

Swift 的字典使用时需要具体规定可以存储键和值类型。不同于 Objective-C 的`NSDictionary``和NSMutableDictionary` 类可以使用任何类型的对象来作键和值并且不提供任何关于这些对象的本质信息。在 Swift 中，在某个特定字典中可以存储的键和值必须提前定义清楚，方法是通过显性类型标注或者类型推断。

Swift 的字典使用`Dictionary<KeyType, ValueType>`定义,其中KeyType是字典中键的数据类型，ValueType是字典中对应于这些键所存储值的数据类型。

KeyType的唯一限制就是可哈希的，这样可以保证它是独一无二的，所有的 Swift 基本类型（例如String，Int， Double和Bool）都是默认可哈希的，并且所有这些类型都可以在字典中当做键使用。

更新字典：

{% highlight swift %}

if let oldValue = airports.updateValue("Dublin Internation", forKey: "DUB") {
    println("The old value for DUB was \(oldValue).")
}
// 输出 "The old value for DUB was Dublin."（DUB原值是dublin）

{% endhighlight %}

使用下标语法来在字典中检索特定键对应的值。由于使用一个没有值的键这种情况是有可能发生的，可选类型返回这个键存在的相关值，否则就返回nil：

{% highlight swift %}

if let airportName = airports["DUB"] {
    println("The name of the airport is \(airportName).")
} else {
    println("That airport is not in the airports dictionary.")
}
// 打印 "The name of the airport is Dublin Internation."（机场的名字是都柏林国际）

{% endhighlight %}

遍历字典，返回元祖：

{% highlight swift %}

for (airportCode, airportName) in airports {
    println("\(airportCode): \(airportName)")
}

{% endhighlight %}

字典元素的遍历顺序和插入顺序可能不同，字典的内容在内部是无序的，所以遍历元素时不能保证顺序。

### 控制流

switch的 case 语句中匹配的值可以是由 case 体内部临时的常量或者变量决定，也可以由where分句描述更复杂的匹配条件。另外不会发生贯穿的情况，如果想贯穿需要使用`fallthrough`。

{% highlight swift %}

let someCharacter: Character = "e"
switch someCharacter {
case "a", "e", "i", "o", "u":
    println("\(someCharacter) is a vowel")
case "b", "c", "d", "f", "g", "h", "j", "k", "l", "m",
"n", "p", "q", "r", "s", "t", "v", "w", "x", "y", "z":
    println("\(someCharacter) is a consonant")
default:
    println("\(someCharacter) is not a vowel or a consonant")
}

{% endhighlight %}

case也可以区间匹配。

case (let x, 0)将匹配一个纵坐标为0的点，并把这个点的横坐标赋给临时的常量x。

where子句用于case中：

{% highlight swift %}

let yetAnotherPoint = (1, -1)
switch yetAnotherPoint {
case let (x, y) where x == y:
    println("(\(x), \(y)) is on the line x == y")
case let (x, y) where x == -y:
    println("(\(x), \(y)) is on the line x == -y")
case let (x, y):
    println("(\(x), \(y)) is just some arbitrary point")
}
// 输出 "(1, -1) is on the line x == -y"

{% endhighlight %}

### 函数

返回元祖：

{% highlight swift %}

func count(string: String) -> (vowels: Int, consonants: Int, others: Int) {
    var vowels = 0, consonants = 0, others = 0
    for character in string {
        switch String(character).lowercaseString {
        case "a", "e", "i", "o", "u":
            ++vowels
        case "b", "c", "d", "f", "g", "h", "j", "k", "l", "m",
          "n", "p", "q", "r", "s", "t", "v", "w", "x", "y", "z":
            ++consonants
        default:
            ++others
        }
    }
    return (vowels, consonants, others)
}

{% endhighlight %}

调用的时候：

{% highlight swift %}

let total = count("some arbitrary string!")
println("\(total.vowels) vowels and \(total.consonants) consonants")
// prints "6 vowels and 13 consonants"

{% endhighlight %}

### 外部参数

有时候，调用函数时，给每个参数命名是非常有用的，因为这些参数名可以指出各个实参的用途是什么。

如果你希望函数的使用者在调用函数时提供参数名字，那就需要给每个参数除了局部参数名外再定义一个外部参数名。外部参数名写在局部参数名之前，用空格分隔。

    func someFunction(externalParameterName localParameterName: Int) {
        // function body goes here, and can use localParameterName
        // to refer to the argument value for that parameter
    }

注意： 如果你提供了外部参数名，那么函数在被调用时，必须使用外部参数名。

以下是个例子，这个函数使用一个结合者（joiner）把两个字符串联在一起：

    func join(s1: String, s2: String, joiner: String) -> String {
        return s1 + joiner + s2
    }

当你调用这个函数时，这三个字符串的用途是不清楚的：

    join("hello", "world", ", ")
    // returns "hello, world"

**为了让这些字符串的用途更为明显，我们为 join 函数添加外部参数名：**

    func join(string s1: String, toString s2: String, withJoiner joiner: String) -> String {
        return s1 + joiner + s2
    }

在这个版本的 join 函数中，第一个参数有一个叫 string 的外部参数名和 s1 的局部参数名，第二个参数有一个叫 toString 的外部参数名和 s2 的局部参数名，第三个参数有一个叫 withJoiner 的外部参数名和 joiner 的局部参数名。

现在，你可以使用这些外部参数名以一种清晰地方式来调用函数了：

    join(string: "hello", toString: "world", withJoiner: ", ")
    // returns "hello, world"

使用外部参数名让第二个版本的 join 函数的调用更为有表现力，更为通顺，同时还保持了函数体是可读的和有明确意图的。



